-- 1. Total claims for two specialties
SELECT specialty_description, SUM(total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
WHERE specialty_description IN ('Interventional Pain Management', 'Pain Management')
GROUP BY specialty_description;

-- 2. UNION to include the overall total
SELECT specialty_description, SUM(total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
WHERE specialty_description IN ('Interventional Pain Management', 'Pain Management')
GROUP BY specialty_description
UNION
SELECT NULL AS specialty_description, SUM(total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
WHERE specialty_description IN ('Interventional Pain Management', 'Pain Management');


-- 3. Now, instead of using UNION, make use of GROUPING SETS (https://www.postgresql.org/docs/10/queries-table-expressions.html#QUERIES-GROUPING-SETS) to achieve the same output.
SELECT specialty_description, SUM(total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
WHERE specialty_description IN ('Interventional Pain Management', 'Pain Management')
GROUP BY GROUPING SETS((specialty_description), ());

-- 4. In addition to comparing the total number of prescriptions by specialty, let's also bring in information about the number of opioid vs. non-opioid claims by these two specialties.
SELECT p.specialty_description, d.opioid_drug_flag, SUM(pr.total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
JOIN drug d ON pr.drug_name = d.drug_name
WHERE p.specialty_description IN ('Interventional Pain Management', 'Pain Management')
GROUP BY GROUPING SETS((p.specialty_description, d.opioid_drug_flag), (p.specialty_description), (d.opioid_drug_flag), ());

-- 5.Modify your query by replacing the GROUPING SETS with ROLLUP(opioid_drug_flag, specialty_description). How is the result different from the output from the previous query?
SELECT p.specialty_description, d.opioid_drug_flag, SUM(pr.total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
JOIN drug d ON pr.drug_name = d.drug_name
WHERE p.specialty_description IN ('Interventional Pain Management', 'Pain Management')
GROUP BY ROLLUP(d.opioid_drug_flag, p.specialty_description);
-- The difference is that ROLLUP creates subtotals at each level starting from the first argument, while GROUPING SETS gives you the totals for each set independently.

-- 6. Switch the order of the variables inside the ROLLUP. That is, use ROLLUP(specialty_description, opioid_drug_flag). 
SELECT p.specialty_description, d.opioid_drug_flag, SUM(pr.total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
JOIN drug d ON pr.drug_name = d.drug_name
WHERE p.specialty_description IN ('Interventional Pain Management', 'Pain Management')
GROUP BY ROLLUP(p.specialty_description, d.opioid_drug_flag);
-- The change in order affects the subtotaling. Now the subtotals are for each specialty, then the grand total.

-- 7. Finally, change your query to use the CUBE function instead of ROLLUP. How does this impact the output?
SELECT p.specialty_description, d.opioid_drug_flag, SUM(pr.total_claim_count) AS total_claims
FROM prescriber p
JOIN prescription pr ON p.npi = pr.npi
JOIN drug d ON pr.drug_name = d.drug_name
WHERE p.specialty_description IN ('Interventional Pain Management', 'Pain Management')
GROUP BY CUBE(p.specialty_description, d.opioid_drug_flag);
-- the cube generates all the possible combinations of the subtotals, including those not generated by ROLLUP.

-- 8. Pivot table with crosstab
CREATE EXTENSION IF NOT EXISTS tablefunc;

WITH DrugCategories AS (
    SELECT drug_name,
           CASE
               WHEN generic_name ILIKE '%hydrocodone%' THEN 'hydrocodone'
               WHEN generic_name ILIKE '%oxycodone%' THEN 'oxycodone'
               WHEN generic_name ILIKE '%oxymorphone%' THEN 'oxymorphone'
               WHEN generic_name ILIKE '%morphine%' THEN 'morphine'
               WHEN generic_name ILIKE '%codeine%' THEN 'codeine'
               WHEN generic_name ILIKE '%fentanyl%' THEN 'fentanyl'
               ELSE NULL  -- Handle cases where no category is matched if needed
           END AS drug_category
    FROM drug
),
city_claims AS (
    SELECT p.nppes_provider_city AS city,
           dc.drug_category,
           SUM(pr.total_claim_count) AS total_claims
    FROM prescriber p
    JOIN prescription pr ON p.npi = pr.npi
    JOIN DrugCategories dc ON pr.drug_name = dc.drug_name
    WHERE p.nppes_provider_city IN ('NASHVILLE', 'MEMPHIS', 'KNOXVILLE', 'CHATTANOOGA') AND dc.drug_category IS NOT NULL -- Filter for the 4 cities
    GROUP BY p.nppes_provider_city, dc.drug_category
)
SELECT city, codeine, fentanyl, hydrocodone, morphine, oxycodone, oxymorphone
FROM crosstab(
    'SELECT city, drug_category, total_claims FROM CityClaims ORDER BY city, drug_category',
    'SELECT DISTINCT drug_category FROM CityClaims ORDER BY drug_category'
) AS ct(city TEXT, codeine BIGINT, fentanyl BIGINT, hydrocodone BIGINT, morphine BIGINT, oxycodone BIGINT, oxymorphone BIGINT);

-- I can't seem to get this one quite working yet